# 정수형
a = 1
b = 2
c = a + b           # 정수형끼리 덧셈 가능
print(c)
d = a * b           # 정수형끼리 곱셈 가능
print(d)
e = a / b           # 정수형끼리 나눗셈 가능
print(e)            # 파이썬, 인간친화적인 언어. 
                    # 정수 / 정수 해도 실수 나온다 (C와 JAVA랑은 다름)

# 실수형

a = 1.1   # 변수에 새로운 값 대입하면 그 값이 적용 (1 -> 1.1)
b = 2.2
c = a + b
print(c)  # 3.3000000000000003

d = a * b
print(d)  # 2.4200000000000004

e = a / b
print(e)

# 3.3, 2,42로 딱 떨어져 나와야 할 것 같은데 그렇지 않다. 
# Why???
# 부동소수점의 문제 때문이다 (부동 소수점 오차) (아래에 자세히)
# 0.1 + 0.2 != 0.3
# 실수끼리 연산하면 아주 찌끄러지만한 오차 값이 존재한다는 것만 알고 있으면 된다.
# 때문에 이런 결과가 발생한다는 것만 알고 있자. 

# 문자형
a = 'hel'
b = 'lo'
c = a + b
print(c)   # 출력 : hello

# 문자 + 숫자
a = 123
b = '45'   # ''가 있기 때문에 45는 숫자가 아니라 문자이다. (''or ""로 묶어져 있는 것은 문자)
# c = a + b
# print(c) # TypeError 발생 : unsupported operand type(s) for +: 'int' and 'str'
           # operand : 컴퓨터에서 조작에 필요한, 또는 조작으로 나타나는 수치의 총칭.
           # 파이썬에서 int타입과 str타입에 +연산은 지원하지 않는다.
           # 만약 두 객체를 +연산하려고 할때는 TypeError가 발생!

           # 둘 다 문자 또는 숫자로 변형해주면 문제해결
           # 우리가 받은 데이터가 있을 때 (ex) 주가 데이터) 모든 데이터가 숫자라는 보장은 없다.
           # 10,000 원 : 숫자와 '원'이 섞여 있을 수 있다. 
           # 10000 + 10000 = 1000010000 : 문자열로 되어 있었음! 20000이라는 결과를 내려면 숫자로 바꿔줘야 한다. 
           # 데이터를 받으면 우리가 쓸 수 있는 형태로 바꿔줘야 한다. 

# 숫자를 문자로 변환 후 + 문자
a = 123
a = str(a) 
print(a) # 123이 출력, 이것은 문자형태이다.
b = '45'
c = a + b
print(c)

# ex) 증권에서 데이터를 받음, 
# 10000이라는 숫자가 10  000 이런 식으로 천 원 단위로 끊어져 있다면?
# 문자 형태로 합쳐서 숫자로 바꿔줘야 한다. 
# This is "형 변환, Type Conversion" (동생을 바꿀 수 없어 형을 바꿈...)

a = 123
b = '45'
b = int(b)      # str은 int로 
c = a + b
print(c)        # 출력 : 168

# 문자열 연산하기
a = 'abcdefgh'
print(a[0])     # index의 첫번째는 항상 0
print(a[3])     # d
print(a[5])     # f
print(a[-1])    # -1 : 뒤에서 1번째 / -(minus) 붙어있면 index 거꾸로 들어가는 것
print(a[-2])    # -2 : 뒤에서 2번째

print(type(a))  # 타입(형)을 알고 싶을 때
                # type이라는 함수 안에 a를 넣음
                # 출력 : <class 'str'> 
                # ".shape, type" : 앞으로 정말 많이 씀, data 확인하기 위해.

b = 'xyz'
print(a + b)    # 출력 : abcdefghxyz

# 문자열 인덱싱(Indexing) , 슬라이스(Slice)
a = 'Hello, Deep Learning' # , 도 사이사이 공백도 모두 문자로 본다
print(a[7])                # 출력 : D
print(a[-1])               # 출력 : g
print(a[-2])               # 출력 : n
print(a[3:9])              # 3번째부터 9번째 앞까지
                           # (즉 index3부터 8까지, [ : ] 여기서 뒤는 항상 하나 빼주기) , 출력 : lo, De
print(a[3:-5])             # 출력 : lo, Deep Lea ( -5 : r, 포함하지 않음)
print(a[:-1])              # 출력 : Hello, Deep Learnin (-1의 위치에서 하나 빼줘야함)
                           # :n : 처음부터 (n-1)번째
print(a[1:])               # 출력 : ello, Deep Learning
                           # n: : index n부터 끝까지 
print(a[5:-4])             # 출력 : , Deep Lear

# 앞으로 엄청 많이 나온다. 행렬에서 많이 쓰임. 


# keras11_split 파일에서 볼 수 있음

# x_train = x[:60]        # : 앞에 아무 것도 없음 : 처음부터 1 ~ 59
# x_val = x[60:80]        # : 60부터 79
# x_test = x[80:]         # : 뒤에 아무 것도 없음 : 80부터 끝까지



############################부동소수점###################################
# 부동 소수점 숫자는 컴퓨터 하드웨어에서 밑(vase)이 2인(이진) 소수로 표현된다.
# 예를 들어, 소수 0.125는 1/10 + 2/100 + 5/1000 의 값을 가지며
# 같은 방식으로 이진 소수 0.001은 값 0/2 + 0/4 + 1/8을 가진다. 
# 이 두 소수는 같은 값을 가지며, 유일한 차이점은 
# 첫 번째가 밑인 10인 분수 표기법으로 작성되었고 두 번째는 밑이 2라는 것
# 대부분의 십진 소수는 정확하게 이진 소수로 표현될 수 없다
# 결과적으로 일반적으로 입력하는 십진 부동 소수점 숫자가 
# 실제로 기계에 저장될 때는 이진 부동 소수점 수로 근사 될 뿐!
# 이 문제는 밑 10에서 따져보면 이해하기 쉽다
# 분수 1/3을 보면, 이 값을 십진 소수로 근사할 수 있다
# 1/3 = 0.3? 더 정확하게 0.33? 더 더 정확하게 0.333?
# 아무리 많은 자릿수를 적어도 결과가 정확하게 1/3이 될 수는 없지만!
# 점점 더 1/3에 가까운 근사치가 된다
# 마찬가지로 아무리 많은 자릿수의 숫자를 사용해도 십진수 0.1은
# 이진(핑클) 소수로 정확하게 표현 될 수 없다!
# 이진법에서 1/10은 무한히 반복되는 소수이다
# 유한한 비트 수에서 멈추면 근삿값을 얻게 된다
# 대부분 기계에서 float는 이진 분수로 근사 되는데 최상위 비트로부터 시작하는
# 53비트를 분자로 사용하고, 2의 거듭제곱 수를 분모로 사용한다
# 1/10의 경우 이진 분수는 3602879701896397 / 2 * 55 인데,
# 실제 값 1/10과 거의 같지만 정확히 같지는 않다
# 많은 사용자는 값이 표시되는 방식 때문에 근사를 인식하지 못한다
# 파이썬은 기계에 저장된 이진 근삿값의 진짜 십진 값에 대한 십진 근삿값을 인쇄할 뿐
# 대부분 기계에서 만약 파이썬이 0.1로 저장된 이진 근삿값의 진짜 십진 값을 출력한다면,
# 이렇게 표시해야 한다

# >>> 0.1
# 0.1000000000000000055511151231257827021181583404541015625

# 이것은 대부분 사람이 유용하다고 생각하는 것보다 많은 숫자이므로, 
# 파이썬은 반올림된 값을 대신 표시하여 숫자를 다룰만하게 만든다

# >>> 1 / 10
# 0.1

# 인쇄된 결과가 정확히 1/10인 것처럼 보여도, 
# 실제 저장된 값은 가장 가까운 표현 가능한 이진소수임!!
# 흥미롭게도, 가장 가까운 근사 이진 소수를 공유하는 여러 다른 십진수가 있다
# 예를 들어, 
# 0.1과 0.10000000000000001 
# 0.1000000000000000055511151231257827021181583404541015625
# 세 개는 모두 3602879701896397 / 2 ** 55 로 근사된다
# 이 십진 값들이 모두 같은 근삿값을 공유하기 때문에 
# EVAL(REPR(x)) == x, 불변을 그대로 유지하면서 그 중 하나를 표시할 수 있다

# 역사적으로, 파이썬 프롬프트와 내장 repr() 함수는 유효 숫자 17개의 숫자인
# 0.10000000000000001 을 선택한다
# 파이썬 3.1부터 이제 파이썬(대부분 시스템에서)이 가장 짧은 것을 선택할 수 있으며
# 단순히 0.1만 표시한다!

# 이것이 이진 부동 소수점의 본질임에 주목!
# 파이썬의 버그도, 코드의 버그도 아니다
# 하드웨어의 부동 소수점 산술을 지원하는 모든 언어에서 같은 종류의 것을 볼 수 있다

# 좀 더 만족스러운 결과를 얻으려면 문자열 formating을 사용하여 
# 제한된 수의 유효 숫자를 생성할 수 있다

#############################################################
# >>> format(math.pi, '.12g')  # give 12 significant digits
# '3.14159265359'

# >>> format(math.pi, '.2f')   # give 2 digits after the point
# '3.14'

# >>> repr(math.pi)
# '3.141592653589793'
#############################################################

# 0.1은 정확히 1/10이 아니므로 0.1 세 개를 합한 것 역시
# 정확히 0.3이 아니다! wow
# >>>.1 + .1 + .1 == .3
# False
# 또한 0.1은 1/10의 정확한 값에 더 가까워질 수도 없고
# 0.3도 3-10의 정확한 값에 더 가까워질 수 없으므로
# round() 함수로 미리 반올림하는 것도 도움이 되지 않는다
# >>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
# False

# 숫자를 의도한 정확한 값에 더 가깝게 만들 수는 없지만
# round() 함수는 사후 반올림에 유용하여 부정확한 값을 가진 결과를 서로 비교할 수 있게 한다
# >>> round(.1 + .1 + .1, 10) == round(.3, 10)
# >>> True
