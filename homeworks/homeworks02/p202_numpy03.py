# 7.3 NumPy 2차원 배열
# 7.3.1 2차원 배열

# 2차원 배열은 행렬에 해당한다
# 'np.array([리스트, 리스트])'로 표기하여 2차원 배열을 만들 수 있다
# ndarray 배열의 내부에는 shape라는 변수가 있어 'nparray배열.shape'로 각 차원의 요소 수를 반환 할 수 있다
# ndarray 변수를 넣지 않고 ndarray 배열 자체를 넣어도 마찬가지로 반환한다

import numpy as np
arr = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr = np.array(arr)
print(arr)
'''
[[1 2 3 4]
 [5 6 7 8]]
'''


print("arr.shape : ", arr.shape) # arr.shape :  (2, 4)

arr_reshape = arr.reshape(4, 2)
print("arr.reshape : \n", arr_reshape)
'''
arr.reshape :
 [[1 2]
 [3 4]
 [5 6]
 [7 8]]
 '''

# 7.3.2 인덱스 참조와 슬라이스
# 2차원 배열의 경우 인덱스를 하나만 지정하면 임의의 행을 배열로 가져올 수 있다
# 인덱스 하나 -> 임의의 행!!

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1]) # [4 5 6]

# 개별 요소, 즉 스칼라값에 도달하려면 인덱스를 두 개 지정해야 한다
# 즉, arr[1][2] 또는 arr[1, 2] 와 같이 접근할 필요가 있다
# arr[1][2]는 arr[1]에서 꺼낸 배열의 세 번째 요소에 접근하고(index는 0부터 시작)
# arr[1, 2]는 2차원 배열의 축을 지정하여 요소에 접근하게 된다
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 2]) # 6

# 2차원 배열을 참조할 때 슬라이스를 사용할 수도 있다
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 1:]) # [5 6]

# 문제
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr)

print(arr[0, -1]) 
print(arr[1:, :2])
'''
3
[[4 5]
 [7 8]]
'''

# 7.3.3 axis
# 2차원 배열에서 axis라는 개념이 중요하다
# axis는 좌표축과 같다! 
# NumPy 함수의 인수로 axis를 설정하는 경우가 많다
# 2차원 배열의 경우 열마다 처리하는 축이 axis = 0, 행마다 처리하는 축이 axis = 1이다
# 예를 들어, ndarray 배열의 sum() 메서드를 살펴보자
# ndarray.sum() 으로 요소를 모두 더할 수 있다
arr = np.array([[1, 2, 3], [4, 5, 6]])

print(arr.sum())
print(arr.sum(axis = 0))
print(arr.sum(axis = 1))
'''
21
[5 7 9]
[ 6 15]
'''
# sum() 메서드에 인수를 지정하지 않으면 단순히 전체 합계가 스칼라로 반환되고
# sum() 메서드에 인수 axis = 0을 지정하면 세로로 더해져서 요소가 세 개인 1차원 배열이 되고
# sum() 메서드에 인수 axis = 1을 지정하면 가로로 더해져서 요소가 두 개인 1차원 배열이 되는 것을 알 수 있다

arr = np.array([[1, 2, 3], [4, 5, 12], [15, 20, 22]])

print(arr.sum(axis = 1)) # [ 6 21 57]

# 7.3.4 팬시 인덱스 참조
# 팬시 인덱스 참조는 인덱스 참조로 인덱스의 배열을 이용하는 방법
# ndarray ㅂ열에서 특정 순서로 행을 추출하려면 그 순서를 나타내는 배열을 인덱스 참조로 전달하면 된다

# 팬시 인덱스 참조는 슬라이스와 달리 항상 원본 데이터의 복사본을 반환하여 새로운 요소를 작성하게 된다
arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
print(arr[[3, 2, 0]])
'''
[[7 8]
 [5 6]
 [1 2]]
'''
print(arr)
'''
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
 원본은 그대로 있다
'''

arr = np.arange(25).reshape(5, 5)
print("arr : \n", arr)
print("arr_new : \n", arr[[1, 3, 0]])
'''
arr :
 [[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]
 [15 16 17 18 19]
 [20 21 22 23 24]]
arr_new :
 [[ 5  6  7  8  9]
 [15 16 17 18 19]
 [ 0  1  2  3  4]]
'''

# 7.3.5 전치 행렬
# 행렬에서 행과 열을 바꾸는 것을 '전치'라고 한다
# 전치 행렬은 행렬의 내적 계산 등에 사용한다
# ndarray를 전치하려면 np.transpose() 함수를 사용하거나 .T를 사용한다

# 문제 : arr을 전치하여 출력
arr = np.arange(10).reshape(2, 5)
print("arr : \n", arr)
# arr_new = np.transpose(arr)
arr_new = arr.T
print("arr_new : \n", arr_new)
'''
arr :
 [[0 1 2 3 4]
 [5 6 7 8 9]]
arr_new :
 [[0 5]
 [1 6]
 [2 7]
 [3 8]
 [4 9]]
'''

# 7.3.6 정렬
# ndarray도 리스트형과 마찬가지로 sort() 메서드로 정렬할 수 있다
# 2차원 배열의 경우 0을 인수로 하면 열 단위로 요소가 정렬되며, 1을 인수로 하면 행 단위로 요소가 정렬된다
# 또한 np.sort() 함수로 정렬할 수 있다
# sort() 메서드와 달리 np.sort() 함수는 정렬된 배열의 복사본을 반환한다!
# -> 메서드와 함수의 차이(하지만 항상 이렇진 않다고 했다)

# 또한 머신러닝에서 자주 사용되는 함수로 argsort() 메서드가 있다
# argsort() 메서드는 정렬된 배열의 인덱스를 반환한다!

arr = np.array([15, 30, 5])
arr.argsort()
print(arr.argsort()) # [2 0 1]

# arr.sort()를 하면 [5 15 30]이 된다
# 원래 배열에서 2번째에 있던 '5'가 0번째 요소, 0번째에 있던 '15'가 1번째 요소,,,,,
# 따라서 [15, 30, 5]를 .argsort() 하면 차례대로 '2번째, 0번째, 1번째' 요소가 되어 [2, 0, 1]이라는 값을 반환

arr = np.array([[8, 4, 2], [3, 5, 1]])
print(arr.argsort())

print(np.sort(arr))

arr.sort(1)
print(arr)
# 열을 정렬하려면 인수를 0, 행을 정렬하려면 인수를 1로
# arr.sort() 안에 열 또는 행을 기준으로 하겠다, 를 명시해줘야 한다
'''
[[2 1 0]
 [2 0 1]]
[[2 4 8]
 [1 3 5]]
[[2 4 8]
 [1 3 5]]
'''

# 7.3.7 행렬 계산
# 행렬 계산을 하기 위한 함수로 두 행렬의 행렬곱을 반환하는 np.dot(a, b)와 노름을 반환하는 np.linalg.norm(a) 등이 있다
# 행렬곱이란 행렬에서 행벡터와 열벡터의 내적 요소로 하는 행렬을 새로 생성하는 것이다
# np.dot(a, b) 함수를 실행하면 행벡터 a와 열벡터 b의 행렬곱이 생성된다

# 노름(norm)은 벡터의 길이를 반환하는 것으로, 요소의 제곱값을 더해 루트를 씌운 것이다
# np.linalg.norm(a) 함수를 실행하면 벡터 a와 b의 노름이 출력된다

# 문제
arr = np.arange(9).reshape(3, 3)


print(np.dot(arr, arr))

vec = arr.reshape(9)
print(np.linalg.norm(vec))

# 7.3.8 통계 함수
# 통계 함수란 ndarray 배열 전체 또는 특정 축을 중심으로 수학적 처리를 수행하는 함수 또는 메서드이다
# 이미 학습한 통계 함수로는 'axis'에서 다루었던 배열의 합을 반환하는 sum() 메서드가 있다

# 자주 사용되는 메서드로는 배열 요소의 평균을 반환하는 mean() 메서드와 np.average() 메서드,
# 최댓값, 최솟값을 반환하는 np.max() 메서드와 np.min() 메서드가 있다
# 또한 요소의 최댓값 또는 최솟값의 인덱스 번호를 반환하는 np.argmax() 메서드와 np.argmin() 메서드도 있다

# 그 밖에더 통계 분야에서 자주 사용되는 '표준 편차'와 '분산'을 반환하는 함수로 
# np.std() 메서드와 np.var() 메서드가 있다
# 이들은 데이터의 편차를 나타내는 지표이다

arr = np.array([[8, 4, 2], [3, 5, 1]])
print("arr의 표준편차 : ", np.std(arr))  # arr의 표준편차 :  2.266911751455907
print("arr의 분산     : ", np.var(arr))  # arr의 분산     :  5.138888888888888

# sum() 메서드에서 axis를 지정해주면 어떤 축을 중심으로 결정했듯이 mean() 메서드 등에서도 마찬가지로 축을 지정할 수 있다
# argmax() 메서드와 argmin() 메서드의 경우에는 axis로 지정한 축마다 최댓값 또는 최솟값의 인덱스를 반환한다
# 한 번 더 : axis = 0은 열마다 처리, axis = 1은 행마다 처리!

arr = np.arange(15).reshape(3, 5) # 3행 5열
print("arr : \n", arr)
print("열의 평균 :", arr.mean(axis = 0))
print("행의 합계 :", arr.sum(axis = 1))
print("최솟값 :", np.min(arr))
print("각 열의 최댓값의 자리 :", np.argmax(arr, axis = 0))
'''
arr :
 [[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
열의 평균 : [5. 6. 7. 8. 9.]
행의 합계 : [10 35 60]
최솟값 : 0
각 열의 최댓값의 자리 : [2 2 2 2 2] # 10, 11, ..., 14는 열을 기준으로 index = 2의 위치이다
'''

# 7.3.9 브로드캐스트
# 크기가 다른 NumPy 배열(이하 ndarray) 간의 연산에는 브로드캐스트(broadcast)라는 처리가 자동으로 이루어진다
# 브로드캐스트는 두 ndaraay 연산시 크기가 작은 배열의 행과 열을 자동으로 큰 배열 쪽에 맞춰준다
# 두 배열의 행이 일치하지 않을 경우에는 행이 적은 쪽이 행이 많은 쪽의 수에 맞추어 부족한 부분을 기존 행에서 복사한다(오~)
# 열이 일치하지 않는 경우에도 마찬가지이다 
# 어떤 배열이든 브로드캐스트가 되는 것은 아니지만, 모든 요소에 동일한 처리를 할 때는 브로드캐스트가 가능하다

x = np.arange(6).reshape(2, 3)
print(x)
print(x + 1)
'''
[[1 2 3]
 [4 5 6]]

브로드 캐스트 된다는 게  
 1 2 3   1 1 1 
 4 5 6 + 1 1 1
이렇게 되는 거라고 보면 된다
'''

# 문제 
x = np.arange(15).reshape(3, 5)
y = np.array([np.arange(5)])

print("x : \n", x)
print("y : \n", y)
'''
x :
 [[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
y :
 [[0 1 2 3 4]]
# 행의 크기가 맞지 않음
'''
z = x - y
print("z : \n", z)
'''
z :
 [[ 0  0  0  0  0]
 [ 5  5  5  5  5]
 [10 10 10 10 10]]
'''



# # 연습 문제
# import numpy as np
# np.random.seed(100)

# arr = np.random.randint(0, 31, (5, 3))
# print(arr)

# arr = arr.T

# print("arr.T : \n", arr)

# '''
# [[ 8 24  3]
#  [ 7 23 15]
#  [16 10 30]
#  [20  2 21]
#  [ 2  2 14]]
# arr.T :
#  [[ 8  7 16 20  2]
#  [24 23 10  2  2]
#  [ 3 15 30 21 14]]
# '''

# arr1 = arr[:, 1:4]
# print(arr1)

# arr1.sort(0)
# print(arr1)

# '''
# [[ 7 23 15]
#  [16 10 30]
#  [20  2 21]]
# [[ 7 15 23]
#  [10 16 30]
#  [ 2 20 21]]
# '''

# print(arr1.mean(axis = 0))
# # [15.         18.66666667 14.33333333]
